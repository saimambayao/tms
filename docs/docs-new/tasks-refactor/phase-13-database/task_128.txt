# Task ID: 128
# Title: Create Final Database Documentation
# Status: pending
# Dependencies: 127
# Priority: high
# Description: Create comprehensive database documentation including schema diagrams, table relationships, data dictionary, migration history, backup procedures, and

# Details:
Create comprehensive database documentation including schema diagrams, table relationships, data dictionary, migration history, backup procedures, and optimization notes. This documentation serves as a reference for developers, DBAs, and system administrators. Generate both technical documentation and visual diagrams using automated tools.

## Implementation Steps:
1. **Install documentation generation tools**:
   ```bash
   # Install django-extensions for graph models
   pip install django-extensions pygraphviz

   # Install for ERD generation
   pip install eralchemy

   # Add to requirements.txt
   echo "django-extensions==3.2.3" >> requirements.txt
   echo "pygraphviz==1.11" >> requirements.txt
   echo "eralchemy==1.3.0" >> requirements.txt
   ```

   ```python
   # config/settings/base.py
   INSTALLED_APPS += ['django_extensions']
   ```

2. **Generate Entity Relationship Diagram**:
   ```bash
   cd /Users/saidamenmambayao/apps/madaris-ms/src

   # Generate ERD for all apps
   python manage.py graph_models -a -o docs/database/erd_all_models.png

   # Generate ERD for specific apps
   python manage.py graph_models users chapters constituents \
     -o docs/database/erd_core_models.png

   # Generate detailed ERD with field types
   python manage.py graph_models -a --all-fields \
     -o docs/database/erd_detailed.png

   # Generate ERD using eralchemy (alternative)
   eralchemy -i postgresql://user:pass@localhost/madaris_db \
     -o docs/database/erd_from_db.png
   ```

3. **Create database schema documentation script**:
   ```python
   # scripts/generate_database_docs.py
   import django
   import os
   from django.db import connection
   from django.apps import apps
   from datetime import datetime

   os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
   django.setup()

   class DatabaseDocumenter:
       """Generate comprehensive database documentation"""

       def __init__(self):
           self.docs = []

       def get_table_info(self):
           """Get detailed information about all tables"""

           with connection.cursor() as cursor:
               # Get table information
               cursor.execute("""
                   SELECT
                       schemaname,
                       tablename,
                       pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
                       (SELECT COUNT(*) FROM information_schema.columns
                        WHERE table_name = t.tablename) as column_count
                   FROM pg_tables t
                   WHERE schemaname = 'public'
                   ORDER BY tablename;
               """)

               tables = cursor.fetchall()

               table_data = []
               for schema, table, size, col_count in tables:
                   # Get row count
                   cursor.execute(f'SELECT COUNT(*) FROM "{table}";')
                   row_count = cursor.fetchone()[0]

                   table_data.append({
                       'name': table,
                       'size': size,
                       'rows': row_count,
                       'columns': col_count
                   })

               return table_data

       def get_column_info(self, table_name):
           """Get detailed column information for a table"""

           with connection.cursor() as cursor:
               cursor.execute("""
                   SELECT
                       column_name,
                       data_type,
                       character_maximum_length,
                       is_nullable,
                       column_default
                   FROM information_schema.columns
                   WHERE table_name = %s
                   ORDER BY ordinal_position;
               """, [table_name])

               columns = cursor.fetchall()

               return [
                   {
                       'name': col[0],
                       'type': col[1],
                       'max_length': col[2],
                       'nullable': col[3],
                       'default': col[4]
                   }
                   for col in columns
               ]

       def get_constraints_info(self, table_name):
           """Get constraints for a table"""

           with connection.cursor() as cursor:
               cursor.execute("""
                   SELECT
                       con.conname as constraint_name,
                       con.contype as constraint_type,
                       pg_get_constraintdef(con.oid) as definition
                   FROM pg_constraint con
                   JOIN pg_class rel ON rel.oid = con.conrelid
                   WHERE rel.relname = %s;
               """, [table_name])

               constraints = cursor.fetchall()

               return [
                   {
                       'name': con[0],
                       'type': con[1],
                       'definition': con[2]
                   }
                   for con in constraints
               ]

       def get_indexes_info(self, table_name):
           """Get indexes for a table"""

           with connection.cursor() as cursor:
               cursor.execute("""
                   SELECT
                       indexname,
                       indexdef,
                       pg_size_pretty(pg_relation_size(indexname::regclass))
                   FROM pg_indexes
                   WHERE tablename = %s
                   AND schemaname = 'public';
               """, [table_name])

               indexes = cursor.fetchall()

               return [
                   {
                       'name': idx[0],
                       'definition': idx[1],
                       'size': idx[2]
                   }
                   for idx in indexes
               ]

       def get_foreign_keys(self):
           """Get all foreign key relationships"""

           with connection.cursor() as cursor:
               cursor.execute("""
                   SELECT
                       tc.table_name,
                       kcu.column_name,
                       ccu.table_name AS foreign_table_name,
                       ccu.column_name AS foreign_column_name,
                       tc.constraint_name,
                       rc.delete_rule,
                       rc.update_rule
                   FROM information_schema.table_constraints AS tc
                   JOIN information_schema.key_column_usage AS kcu
                       ON tc.constraint_name = kcu.constraint_name
                   JOIN information_schema.constraint_column_usage AS ccu
                       ON ccu.constraint_name = tc.constraint_name
                   JOIN information_schema.referential_constraints AS rc
                       ON tc.constraint_name = rc.constraint_name
                   WHERE tc.constraint_type = 'FOREIGN KEY'
                   AND tc.table_schema = 'public'
                   ORDER BY tc.table_name, kcu.column_name;
               """)

               return cursor.fetchall()

       def generate_data_dictionary(self):
           """Generate complete data dictionary"""

           print("Generating data dictionary...")

           tables = self.get_table_info()

           doc = f"""# Database Data Dictionary

   **Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
   **Database:** Tarbiyyah Management System
   **Version:** Phase 13 - Final

   ---

   ## Database Overview

   **Total Tables:** {len(tables)}
   **Total Size:** {sum(float(t['size'].split()[0]) for t in tables if t['size'].split()[1] == 'kB')} kB

   ---

   ## Tables

   """

           for table in tables:
               doc += f"\n### {table['name']}\n\n"
               doc += f"**Size:** {table['size']} | **Rows:** {table['rows']:,} | **Columns:** {table['columns']}\n\n"

               # Get Django model info if exists
               model = None
               for app_model in apps.get_models():
                   if app_model._meta.db_table == table['name']:
                       model = app_model
                       break

               if model:
                   doc += f"**Django Model:** `{model.__module__}.{model.__name__}`\n\n"
                   doc += f"**Description:** {model.__doc__ or 'No description'}\n\n"

               # Columns
               doc += "#### Columns\n\n"
               doc += "| Column | Type | Nullable | Default |\n"
               doc += "|--------|------|----------|--------|\n"

               columns = self.get_column_info(table['name'])
               for col in columns:
                   col_type = col['type']
                   if col['max_length']:
                       col_type += f"({col['max_length']})"

                   default = col['default'] or '-'
                   doc += f"| {col['name']} | {col_type} | {col['nullable']} | {default} |\n"

               # Constraints
               constraints = self.get_constraints_info(table['name'])
               if constraints:
                   doc += "\n#### Constraints\n\n"
                   for con in constraints:
                       constraint_types = {
                           'p': 'PRIMARY KEY',
                           'f': 'FOREIGN KEY',
                           'c': 'CHECK',
                           'u': 'UNIQUE'
                       }
                       con_type = constraint_types.get(con['type'], con['type'])
                       doc += f"- **{con['name']}** ({con_type}): `{con['definition']}`\n"

               # Indexes
               indexes = self.get_indexes_info(table['name'])
               if indexes:
                   doc += "\n#### Indexes\n\n"
                   doc += "| Index Name | Size | Definition |\n"
                   doc += "|------------|------|------------|\n"
                   for idx in indexes:
                       doc += f"| {idx['name']} | {idx['size']} | {idx['definition'][:60]}... |\n"

               doc += "\n---\n"

           return doc

       def generate_relationship_docs(self):
           """Document foreign key relationships"""

           print("Documenting relationships...")

           foreign_keys = self.get_foreign_keys()

           doc = f"""# Database Relationships

   **Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

   ---

   ## Foreign Key Relationships

   **Total Foreign Keys:** {len(foreign_keys)}

   ---

   ## Relationship Details

   | From Table | From Column | To Table | To Column | On Delete | On Update |
   |------------|-------------|----------|-----------|-----------|-----------|
   """

           for fk in foreign_keys:
               table, column, ref_table, ref_column, constraint, delete_rule, update_rule = fk
               doc += f"| {table} | {column} | {ref_table} | {ref_column} | {delete_rule} | {update_rule} |\n"

           doc += "\n---\n\n## Relationship Graph\n\n"
           doc += "See `erd_core_models.png` for visual representation.\n\n"

           doc += "---\n\n## Key Relationships\n\n"
           doc += "### User -> Student (One-to-One)\n"
           doc += "- Each student account has one user account\n"
           doc += "- Foreign key: `constituents_student.user_id -> users_user.id`\n\n"

           doc += "### Student -> Enrollment (One-to-Many)\n"
           doc += "- Students can have multiple enrollments (different years/madrasahs)\n"
           doc += "- Foreign key: `chapters_madrasahenrollment.student_id -> constituents_student.id`\n\n"

           doc += "### Madrasah -> Enrollment (One-to-Many)\n"
           doc += "- Each madrasah has many student enrollments\n"
           doc += "- Foreign key: `chapters_madrasahenrollment.madrasah_id -> chapters_madrasah.id`\n\n"

           return doc

       def generate_migration_history(self):
           """Document migration history"""

           print("Documenting migration history...")

           with connection.cursor() as cursor:
               cursor.execute("""
                   SELECT app, name, applied
                   FROM django_migrations
                   ORDER BY applied DESC
                   LIMIT 50;
               """)

               migrations = cursor.fetchall()

           doc = f"""# Migration History

   **Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

   ---

   ## Recent Migrations

   | App | Migration | Applied |
   |-----|-----------|---------|
   """

           for migration in migrations:
               app, name, applied = migration
               doc += f"| {app} | {name} | {applied.strftime('%Y-%m-%d %H:%M')} |\n"

           return doc

       def generate_backup_procedures(self):
           """Document backup and restore procedures"""

           doc = f"""# Database Backup & Restore Procedures

   **Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

   ---

   ## Backup Procedure

   ### 1. Full Database Backup (PostgreSQL)

   ```bash
   # Create backup
   pg_dump -h localhost -U postgres -d madaris_db \\
     -F c -b -v -f "backups/backup_$(date +%Y%m%d_%H%M%S).dump"

   # Verify backup
   pg_restore --list backups/backup_*.dump | head -20
   ```

   ### 2. Schema-Only Backup

   ```bash
   pg_dump -h localhost -U postgres -d madaris_db \\
     --schema-only -f "backups/schema_$(date +%Y%m%d).sql"
   ```

   ### 3. Specific Table Backup

   ```bash
   pg_dump -h localhost -U postgres -d madaris_db \\
     -t users_user -t chapters_madrasah \\
     -f "backups/core_tables_$(date +%Y%m%d).sql"
   ```

   ---

   ## Restore Procedure

   ### 1. Full Database Restore

   ```bash
   # Drop existing database (CAUTION!)
   dropdb madaris_db

   # Create new database
   createdb madaris_db

   # Restore from backup
   pg_restore -h localhost -U postgres -d madaris_db \\
     -v backups/backup_20250101_120000.dump
   ```

   ### 2. Selective Table Restore

   ```bash
   # Restore only specific tables
   pg_restore -h localhost -U postgres -d madaris_db \\
     -t users_user -t chapters_madrasah \\
     backups/backup_20250101_120000.dump
   ```

   ---

   ## Backup Schedule

   - **Daily**: Automated full backup at 2:00 AM
   - **Weekly**: Schema-only backup every Sunday
   - **Before Migrations**: Manual backup before any schema changes
   - **Before Deployments**: Manual backup before production deployment

   ---

   ## Backup Retention

   - Daily backups: Keep for 7 days
   - Weekly backups: Keep for 4 weeks
   - Monthly backups: Keep for 12 months
   - Pre-migration backups: Keep indefinitely

   ---

   ## Backup Storage

   1. **Primary**: Local server `/backups` directory
   2. **Secondary**: AWS S3 bucket `s3://madaris-backups/`
   3. **Tertiary**: External hard drive (offline backup)

   """

           return doc

       def generate_common_queries(self):
           """Document common queries"""

           doc = f"""# Common Database Queries

   **Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

   ---

   ## User Management

   ### Get all active teachers
   ```sql
   SELECT * FROM users_user
   WHERE role = 'asatidz' AND is_active = true;
   ```

   ### Get user with student details
   ```sql
   SELECT u.*, s.*
   FROM users_user u
   JOIN constituents_student s ON s.user_id = u.id
   WHERE u.role = 'student';
   ```

   ---

   ## Madrasah Queries

   ### Get active madrasahs with enrollment counts
   ```sql
   SELECT
       m.id,
       m.name,
       COUNT(e.id) as enrollment_count
   FROM chapters_madrasah m
   LEFT JOIN chapters_madrasahenrollment e ON e.madrasah_id = m.id
   WHERE m.is_active = true
   GROUP BY m.id, m.name
   ORDER BY enrollment_count DESC;
   ```

   ---

   ## Student Queries

   ### Get students by enrollment status
   ```sql
   SELECT * FROM constituents_student
   WHERE enrollment_status = 'active'
   ORDER BY student_number;
   ```

   ### Get students with their current enrollments
   ```sql
   SELECT
       s.student_number,
       u.first_name,
       u.last_name,
       m.name as madrasah_name,
       e.start_date,
       e.end_date
   FROM constituents_student s
   JOIN users_user u ON s.user_id = u.id
   JOIN chapters_madrasahenrollment e ON e.student_id = s.id
   JOIN chapters_madrasah m ON e.madrasah_id = m.id
   WHERE e.end_date IS NULL OR e.end_date > CURRENT_DATE
   ORDER BY m.name, u.last_name;
   ```

   """

           return doc

       def generate_all_docs(self):
           """Generate all documentation"""

           print("=" * 60)
           print("DATABASE DOCUMENTATION GENERATOR")
           print("=" * 60)
           print()

           # Create docs directory
           os.makedirs('docs/database', exist_ok=True)

           # Generate each document
           data_dict = self.generate_data_dictionary()
           with open('docs/database/DATA_DICTIONARY.md', 'w') as f:
               f.write(data_dict)
           print("✓ Data dictionary generated")

           relationships = self.generate_relationship_docs()
           with open('docs/database/RELATIONSHIPS.md', 'w') as f:
               f.write(relationships)
           print("✓ Relationships documented")

           migration_history = self.generate_migration_history()
           with open('docs/database/MIGRATION_HISTORY.md', 'w') as f:
               f.write(migration_history)
           print("✓ Migration history documented")

           backup_docs = self.generate_backup_procedures()
           with open('docs/database/BACKUP_PROCEDURES.md', 'w') as f:
               f.write(backup_docs)
           print("✓ Backup procedures documented")

           common_queries = self.generate_common_queries()
           with open('docs/database/COMMON_QUERIES.md', 'w') as f:
               f.write(common_queries)
           print("✓ Common queries documented")

           print()
           print("=" * 60)
           print("DOCUMENTATION COMPLETE")
           print("=" * 60)
           print("\nDocuments created:")
           print("  - docs/database/DATA_DICTIONARY.md")
           print("  - docs/database/RELATIONSHIPS.md")
           print("  - docs/database/MIGRATION_HISTORY.md")
           print("  - docs/database/BACKUP_PROCEDURES.md")
           print("  - docs/database/COMMON_QUERIES.md")

   if __name__ == '__main__':
       documenter = DatabaseDocumenter()
       documenter.generate_all_docs()
   ```

4. **Generate all documentation**:
   ```bash
   cd /Users/saidamenmambayao/apps/madaris-ms/src
   python scripts/generate_database_docs.py
   ```

5. **Create database README**:
   ```bash
   cat > docs/database/README.md << 'EOF'
   # Tarbiyyah Management System - Database Documentation

   ## Overview

   This directory contains comprehensive documentation for the Tarbiyyah Management System database.

   ## Documents

   - **[DATA_DICTIONARY.md](DATA_DICTIONARY.md)** - Complete data dictionary with all tables, columns, and constraints
   - **[RELATIONSHIPS.md](RELATIONSHIPS.md)** - Foreign key relationships and entity relationships
   - **[MIGRATION_HISTORY.md](MIGRATION_HISTORY.md)** - History of database migrations
   - **[BACKUP_PROCEDURES.md](BACKUP_PROCEDURES.md)** - Backup and restore procedures
   - **[COMMON_QUERIES.md](COMMON_QUERIES.md)** - Commonly used SQL queries

   ## Diagrams

   - **erd_all_models.png** - Entity Relationship Diagram (all models)
   - **erd_core_models.png** - ERD (core models only)
   - **erd_detailed.png** - Detailed ERD with field types

   ## Database Statistics

   Run `python scripts/generate_database_docs.py` to regenerate documentation.

   ## Maintenance

   Documentation should be regenerated:
   - After major schema changes
   - After Phase completions
   - Before major releases
   - Quarterly for audit purposes

   ---

   **Last Updated:** $(date +%Y-%m-%d)
   EOF
   ```

6. **Document optimization notes**:
   ```bash
   cp docs/INDEX_OPTIMIZATION_PLAN.md docs/database/
   cp docs/QUERY_OPTIMIZATION_REPORT.md docs/database/
   cp docs/DATA_INTEGRITY_REPORT.md docs/database/
   ```

7. **Create database maintenance schedule**:
   ```bash
   cat > docs/database/MAINTENANCE_SCHEDULE.md << 'EOF'
   # Database Maintenance Schedule

   ## Daily Tasks
   - [ ] Automated backup at 2:00 AM
   - [ ] Check disk space usage
   - [ ] Monitor slow query log

   ## Weekly Tasks
   - [ ] Review query performance metrics
   - [ ] Check for failed backup jobs
   - [ ] Analyze table bloat
   - [ ] Update statistics: `ANALYZE;`

   ## Monthly Tasks
   - [ ] Full VACUUM: `VACUUM FULL ANALYZE;`
   - [ ] Review and archive old logs
   - [ ] Test backup restore procedure
   - [ ] Review index usage statistics
   - [ ] Check for missing indexes

   ## Quarterly Tasks
   - [ ] Regenerate documentation
   - [ ] Review and optimize slow queries
   - [ ] Database performance audit
   - [ ] Update backup retention policy
   EOF
   ```

8. **Verify all documentation**:
   ```bash
   ls -lh docs/database/
   ```

9. **Document completion**:
   ```bash
   echo "## Task 128 Complete - $(date)" >> docs/PHASE_13_LOG.md
   echo "- Database documentation created" >> docs/PHASE_13_LOG.md
   echo "- ERD diagrams generated" >> docs/PHASE_13_LOG.md
   echo "- Data dictionary complete" >> docs/PHASE_13_LOG.md
   echo "- Backup procedures documented" >> docs/PHASE_13_LOG.md
   echo "- Documentation location: docs/database/" >> docs/PHASE_13_LOG.md
   ```

## Acceptance Criteria:
- Entity Relationship Diagram (ERD) generated
- Data dictionary created with all tables and columns
- Foreign key relationships documented
- Indexes and constraints documented
- Migration history documented
- Backup and restore procedures documented
- Query optimization notes included
- Database statistics included (table sizes, row counts)
- Common queries documented with examples
- Database maintenance schedule documented

## Files Modified:
- `scripts/generate_database_docs.py (create)`
- `docs/database/README.md (create)`
- `docs/database/DATA_DICTIONARY.md (create)`
- `docs/database/RELATIONSHIPS.md (create)`
- `docs/database/MIGRATION_HISTORY.md (create)`
- `docs/database/BACKUP_PROCEDURES.md (create)`
- `docs/database/COMMON_QUERIES.md (create)`
- `docs/database/MAINTENANCE_SCHEDULE.md (create)`
- `docs/database/erd_all_models.png (create)`
- `docs/database/erd_core_models.png (create)`
- `docs/database/erd_detailed.png (create)`
- `requirements.txt (update)`
- `docs/PHASE_13_LOG.md (update)`

## Important Notes:
- Documentation should be regenerated after major changes
- Keep documentation in version control
- ERD diagrams help visualize database structure
- Include backup procedures for disaster recovery
- Document common queries for developers
- Estimate: 90 minutes
- Risk Level: NONE (documentation only)

## Backup Requirements:
- No backup needed (documentation task only)
- Commit documentation to git repository
- Store diagrams in multiple formats (PNG, PDF)

## Data Integrity Checks:
- Verify documentation matches actual database schema
- Test all documented queries work correctly
- Ensure ERD diagrams are up-to-date
- Validate backup procedures by testing restore

# Test Strategy:
1. Verify backup file exists and has reasonable size
2. Restore on test database to verify integrity
3. Confirm all tables present in restored database
4. Compare row counts with original database
5. Verify migration file syntax with `python manage.py sqlmigrate`
6. Test forward migration on staging database
7. Test reverse migration to ensure rollback works
8. Verify no data loss during migration
9. Run full test suite to catch regressions
10. Login to Django admin as superuser
11. Verify models appear in admin interface
12. Test create, read, update, delete operations
13. Verify list display, filters, and search work