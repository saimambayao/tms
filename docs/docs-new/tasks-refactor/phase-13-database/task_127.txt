# Task ID: 127
# Title: Optimize Query Performance
# Status: pending
# Dependencies: 126
# Priority: high
# Description: Analyze and optimize slow database queries identified through application profiling. Rewrite inefficient queries, add strategic indexes, implement que

# Details:
Analyze and optimize slow database queries identified through application profiling. Rewrite inefficient queries, add strategic indexes, implement query result caching, and optimize ORM usage. Use Django Debug Toolbar and database query logs to identify bottlenecks. This is a PERFORMANCE OPTIMIZATION task focused on improving response times.

## Implementation Steps:
1. **Create Database Backup (MANDATORY)**:
   ```bash
   pg_dump -h localhost -U postgres -d madaris_db \
     -F c -b -v -f "backups/db_backup_task127_$(date +%Y%m%d_%H%M%S).dump"

   echo "=== Task 127 Backup - $(date) ===" >> backups/BACKUP_LOG.md
   ```

2. **Enable Django query logging**:
   ```python
   # config/settings/development.py

   # Enable query logging in development
   LOGGING = {
       'version': 1,
       'disable_existing_loggers': False,
       'handlers': {
           'console': {
               'class': 'logging.StreamHandler',
           },
           'file': {
               'class': 'logging.FileHandler',
               'filename': 'logs/django_queries.log',
           },
       },
       'loggers': {
           'django.db.backends': {
               'level': 'DEBUG',
               'handlers': ['console', 'file'],
           },
       },
   }
   ```

3. **Install and configure Django Debug Toolbar**:
   ```bash
   pip install django-debug-toolbar

   # Add to requirements.txt
   echo "django-debug-toolbar==4.2.0" >> requirements.txt
   ```

   ```python
   # config/settings/development.py
   INSTALLED_APPS += ['debug_toolbar']
   MIDDLEWARE += ['debug_toolbar.middleware.DebugToolbarMiddleware']

   INTERNAL_IPS = ['127.0.0.1']

   # config/urls.py
   if settings.DEBUG:
       import debug_toolbar
       urlpatterns = [
           path('__debug__/', include(debug_toolbar.urls)),
       ] + urlpatterns
   ```

4. **Create query profiling script**:
   ```python
   # scripts/profile_slow_queries.py
   import django
   import os
   import time
   from django.db import connection, reset_queries
   from django.conf import settings
   from django.test.utils import override_settings

   os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
   django.setup()

   # Enable query logging
   settings.DEBUG = True

   from apps.chapters.models import Madrasah
   from apps.constituents.models import Student
   from apps.users.models import User

   class QueryProfiler:
       """Profile database queries and identify slow ones"""

       def __init__(self, threshold_ms=100):
           self.threshold_ms = threshold_ms
           self.slow_queries = []

       def profile_view_queries(self, view_name, view_func):
           """Profile queries generated by a view"""

           print(f"\nProfiling: {view_name}")
           reset_queries()

           start_time = time.time()
           view_func()  # Execute view logic
           elapsed_time = (time.time() - start_time) * 1000

           queries = connection.queries
           total_query_time = sum(float(q['time']) * 1000 for q in queries)

           print(f"  Total time: {elapsed_time:.2f}ms")
           print(f"  Query time: {total_query_time:.2f}ms")
           print(f"  Query count: {len(queries)}")

           # Identify slow queries
           for query in queries:
               query_time = float(query['time']) * 1000
               if query_time > self.threshold_ms:
                   self.slow_queries.append({
                       'view': view_name,
                       'sql': query['sql'],
                       'time_ms': query_time
                   })

                   print(f"  ⚠️  SLOW QUERY ({query_time:.2f}ms): {query['sql'][:80]}...")

           return {
               'view': view_name,
               'total_time': elapsed_time,
               'query_time': total_query_time,
               'query_count': len(queries),
               'slow_queries': len([q for q in queries if float(q['time']) * 1000 > self.threshold_ms])
           }

       def test_common_views(self):
           """Test common view patterns for N+1 problems"""

           results = []

           # Test 1: List all madrasahs with their enrollments (potential N+1)
           def madrasah_list():
               madrasahs = Madrasah.objects.all()
               for madrasah in madrasahs:
                   # This causes N+1 if not optimized
                   enrollment_count = madrasah.enrollments.count()

           results.append(self.profile_view_queries('madrasah_list_unoptimized', madrasah_list))

           # Test 2: Optimized version with select_related
           def madrasah_list_optimized():
               madrasahs = Madrasah.objects.prefetch_related('enrollments').all()
               for madrasah in madrasahs:
                   enrollment_count = madrasah.enrollments.count()

           results.append(self.profile_view_queries('madrasah_list_optimized', madrasah_list_optimized))

           # Test 3: Student list with user data (N+1 on user)
           def student_list():
               students = Student.objects.all()
               for student in students:
                   username = student.user.username  # N+1 problem

           results.append(self.profile_view_queries('student_list_unoptimized', student_list))

           # Test 4: Optimized with select_related
           def student_list_optimized():
               students = Student.objects.select_related('user').all()
               for student in students:
                   username = student.user.username

           results.append(self.profile_view_queries('student_list_optimized', student_list_optimized))

           # Test 5: Complex query with multiple joins
           def complex_query():
               # Fetch students with their users, enrollments, and madrasahs
               students = Student.objects.select_related('user').prefetch_related(
                   'enrollments__madrasah'
               ).all()[:50]

               for student in students:
                   user = student.user
                   enrollments = student.enrollments.all()
                   for enrollment in enrollments:
                       madrasah = enrollment.madrasah

           results.append(self.profile_view_queries('complex_query_optimized', complex_query))

           return results

       def generate_optimization_report(self, results):
           """Generate report with optimization recommendations"""

           report = f"""# Query Performance Optimization Report

   **Generated:** {time.strftime('%Y-%m-%d %H:%M:%S')}
   **Phase:** 13 - Database Final Cleanup
   **Task:** 127
   **Slow Query Threshold:** {self.threshold_ms}ms

   ---

   ## Query Performance Summary

   | View | Total Time | Query Time | Query Count | Slow Queries |
   |------|------------|------------|-------------|--------------|
   """

           for result in results:
               report += f"| {result['view']} | {result['total_time']:.2f}ms | {result['query_time']:.2f}ms | {result['query_count']} | {result['slow_queries']} |\n"

           report += "\n---\n\n## Slow Queries Detected\n\n"

           if self.slow_queries:
               report += f"Found {len(self.slow_queries)} queries exceeding {self.threshold_ms}ms threshold:\n\n"

               for i, query in enumerate(self.slow_queries, 1):
                   report += f"### {i}. {query['view']} ({query['time_ms']:.2f}ms)\n\n"
                   report += f"```sql\n{query['sql'][:500]}\n```\n\n"
           else:
               report += "✅ No slow queries detected!\n\n"

           report += "---\n\n## Optimization Recommendations\n\n"

           report += """### 1. Use select_related() for Foreign Keys

   **Before:**
   ```python
   students = Student.objects.all()
   for student in students:
       username = student.user.username  # N+1 query
   ```

   **After:**
   ```python
   students = Student.objects.select_related('user').all()
   for student in students:
       username = student.user.username  # Single JOIN query
   ```

   ### 2. Use prefetch_related() for Reverse Relations

   **Before:**
   ```python
   madrasahs = Madrasah.objects.all()
   for madrasah in madrasahs:
       enrollments = madrasah.enrollments.all()  # N+1 query
   ```

   **After:**
   ```python
   madrasahs = Madrasah.objects.prefetch_related('enrollments').all()
   for madrasah in madrasahs:
       enrollments = madrasah.enrollments.all()  # Single query with prefetch
   ```

   ### 3. Use only() to Load Specific Fields

   **Before:**
   ```python
   users = User.objects.all()  # Loads all fields
   ```

   **After:**
   ```python
   users = User.objects.only('id', 'username', 'email')  # Loads only needed fields
   ```

   ### 4. Use defer() to Exclude Large Fields

   ```python
   madrasahs = Madrasah.objects.defer('description', 'notes')  # Skip text fields
   ```

   ### 5. Use Database Query Caching

   ```python
   from django.core.cache import cache

   def get_active_madrasahs():
       cache_key = 'active_madrasahs'
       madrasahs = cache.get(cache_key)

       if madrasahs is None:
           madrasahs = list(Madrasah.objects.filter(is_active=True))
           cache.set(cache_key, madrasahs, 300)  # Cache for 5 minutes

       return madrasahs
   ```

   ### 6. Use Aggregation Instead of Python Loops

   **Before:**
   ```python
   total_students = sum(m.enrollments.count() for m in madrasahs)  # Slow
   ```

   **After:**
   ```python
   from django.db.models import Count
   result = Madrasah.objects.aggregate(total=Count('enrollments'))
   total_students = result['total']
   ```

   ---

   ## Next Steps

   1. Review slow queries identified above
   2. Apply select_related/prefetch_related optimizations
   3. Re-run profiler to measure improvement
   4. Implement caching for read-heavy queries
   5. Update views with optimized queries
   6. Proceed to task_128.txt (Create Final Database Documentation)

   """

           return report

   if __name__ == '__main__':
       print("=" * 60)
       print("QUERY PERFORMANCE PROFILER - PHASE 13")
       print("=" * 60)

       profiler = QueryProfiler(threshold_ms=100)
       results = profiler.test_common_views()

       report = profiler.generate_optimization_report(results)

       with open('docs/QUERY_OPTIMIZATION_REPORT.md', 'w') as f:
           f.write(report)

       print("\n✅ Profiling complete!")
       print(f"Report saved to: docs/QUERY_OPTIMIZATION_REPORT.md")
       print(f"Slow queries found: {len(profiler.slow_queries)}")
   ```

5. **Run query profiler**:
   ```bash
   cd /Users/saidamenmambayao/apps/madaris-ms/src
   python scripts/profile_slow_queries.py
   ```

6. **Analyze query execution plans**:
   ```python
   # scripts/explain_queries.py
   from django.db import connection

   def explain_query(sql):
       """Run EXPLAIN ANALYZE on a query"""

       with connection.cursor() as cursor:
           cursor.execute(f"EXPLAIN ANALYZE {sql}")
           plan = cursor.fetchall()

       print("\nQuery Execution Plan:")
       print("=" * 60)
       for line in plan:
           print(line[0])

   # Test specific queries
   explain_query("""
       SELECT * FROM constituents_student s
       JOIN users_user u ON s.user_id = u.id
       WHERE u.role = 'student'
       LIMIT 100;
   """)
   ```

7. **Implement query optimizations in views**:
   ```python
   # Example: Optimize student list view
   # apps/constituents/views.py

   from django.views.generic import ListView
   from .models import Student

   class StudentListView(ListView):
       model = Student
       template_name = 'students/student_list.html'
       context_object_name = 'students'

       def get_queryset(self):
           # BEFORE (N+1 problem):
           # return Student.objects.all()

           # AFTER (optimized):
           return Student.objects.select_related(
               'user',
               'current_madrasah'
           ).prefetch_related(
               'enrollments__madrasah',
               'enrollments__academic_year'
           ).only(
               'id', 'student_number', 'enrollment_status',
               'user__username', 'user__email', 'user__first_name', 'user__last_name'
           )
   ```

8. **Implement query caching for read-heavy data**:
   ```python
   # apps/chapters/views.py
   from django.core.cache import cache
   from django.utils.decorators import method_decorator
   from django.views.decorators.cache import cache_page

   class MadrasahListView(ListView):
       model = Madrasah

       @method_decorator(cache_page(60 * 5))  # Cache for 5 minutes
       def dispatch(self, *args, **kwargs):
           return super().dispatch(*args, **kwargs)

       def get_queryset(self):
           cache_key = 'madrasah_list_active'
           queryset = cache.get(cache_key)

           if queryset is None:
               queryset = Madrasah.objects.filter(
                   is_active=True
               ).select_related(
                   'region', 'district'
               ).prefetch_related(
                   'enrollments'
               ).order_by('name')

               cache.set(cache_key, queryset, 300)  # 5 minutes

           return queryset
   ```

9. **Run performance benchmarks after optimization**:
   ```bash
   # Re-run profiler
   python scripts/profile_slow_queries.py

   # Compare before/after
   python scripts/compare_query_performance.py \
     logs/queries_before.log \
     logs/queries_after.log
   ```

10. **Document query optimizations**:
    ```bash
    echo "## Task 127 Complete - $(date)" >> docs/PHASE_13_LOG.md
    echo "- Query performance optimized" >> docs/PHASE_13_LOG.md
    echo "- N+1 queries fixed: [count]" >> docs/PHASE_13_LOG.md
    echo "- Caching implemented: [count] views" >> docs/PHASE_13_LOG.md
    echo "- Average query time reduced by: [X%]" >> docs/PHASE_13_LOG.md
    ```

## Acceptance Criteria:
- Database backup created before optimization
- Slow queries identified via profiling (>100ms)
- Query execution plans analyzed (EXPLAIN ANALYZE)
- N+1 query problems identified and fixed
- Select_related/prefetch_related added where appropriate
- Database query caching implemented for read-heavy queries
- Query benchmarks compared (before/after)
- ORM queries optimized (only() and defer() used appropriately)
- Raw SQL used only where necessary and well-documented
- Performance improvements documented and measured

## Files Modified:
- `scripts/profile_slow_queries.py (create)`
- `scripts/explain_queries.py (create)`
- `scripts/compare_query_performance.py (create)`
- `docs/QUERY_OPTIMIZATION_REPORT.md (create)`
- `config/settings/development.py (update - add query logging)`
- `config/urls.py (update - add debug toolbar)`
- `apps/constituents/views.py (update - optimize queries)`
- `apps/chapters/views.py (update - optimize queries)`
- `apps/users/views.py (update - optimize queries)`
- `requirements.txt (update - add django-debug-toolbar)`
- `docs/PHASE_13_LOG.md (update)`
- `backups/db_backup_task127_[timestamp].dump (create)`

## Important Notes:
- Focus on queries that are actually slow (>100ms)
- Use Django Debug Toolbar to identify N+1 problems
- Test optimizations don't change query results
- Caching is great for read-heavy data
- Monitor cache hit rates
- Don't over-optimize - premature optimization is bad
- Estimate: 120 minutes
- Risk Level: LOW (query optimization, no schema changes)

## Backup Requirements:
1. **Pre-Optimization Backup**: Full database dump
2. **Benchmark Data**: Save query logs before optimization
3. **Rollback Plan**: Keep original view code for comparison

## Data Integrity Checks:
- Verify optimized queries return same results as originals
- Test all views still function correctly
- Check query count decreased as expected
- Monitor application performance after deployment
- Ensure caching doesn't serve stale data

# Test Strategy:
1. Verify app appears in INSTALLED_APPS
2. Run migrations successfully
3. Import app models without errors
4. Verify app shows in Django admin
5. Test form validation with valid data
6. Test form validation with invalid data
7. Verify error messages display correctly
8. Test form submission and data persistence
9. Test CSRF protection