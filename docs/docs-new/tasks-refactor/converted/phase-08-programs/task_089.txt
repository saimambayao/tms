# Task ID: 089
# Title: Update Program Admin Interface
# Status: pending
# Dependencies: 088
# Priority: medium
# Description: Update Django admin interface for MinistryProgram, ProgramEnrollment, and related models to support educational program management. Add filters, searc

# Details:
Update Django admin interface for MinistryProgram, ProgramEnrollment, and related models to support educational program management. Add filters, search, actions, and inlines for efficient administration.

## Implementation Steps:
1. Update MinistryProgramAdmin in apps/services/admin.py:
   ```python
   # Update or add to admin.py:
   from django.contrib import admin
   from django.utils.html import format_html
   from django.db.models import Count
   from .models import (
       MinistryProgram,
       ProgramEnrollment,
       ProgramRequirement,
       EnrollmentRequirementStatus
   )
   from .forms import ProgramEnrollmentAdminForm, RequirementVerificationForm

   class ProgramRequirementInline(admin.TabularInline):
       model = ProgramRequirement
       extra = 1
       fields = [
           'requirement_type',
           'title',
           'description',
           'is_mandatory',
           'verification_method',
           'order',
       ]
       ordering = ['order']

   @admin.register(MinistryProgram)
   class MinistryProgramAdmin(admin.ModelAdmin):
       list_display = [
           'code',
           'title',
           'program_category_badge',
           'program_source',
           'grade_levels',
           'status_badge',
           'enrollment_info',
           'start_date',
           'is_accepting_applications',
       ]
       list_filter = [
           'status',
           'program_category',
           'program_source',
           'grade_levels',
           'academic_term',
           'accreditation_status',
           'is_public',
           'is_featured',
           'ministry',
       ]
       search_fields = [
           'code',
           'title',
           'description',
           'target_beneficiaries',
           'geographic_coverage',
       ]
       prepopulated_fields = {'slug': ('title',)}
       date_hierarchy = 'start_date'
       readonly_fields = [
           'created_at',
           'updated_at',
           'enrollment_stats',
           'requirements_summary',
       ]
       inlines = [ProgramRequirementInline]

       fieldsets = (
           ('Basic Information', {
               'fields': (
                   'code',
                   'title',
                   'slug',
                   'ministry',
                   'program_source',
                   'program_category',
                   'ppa_type',
               )
           }),
           ('Education Details', {
               'fields': (
                   'madrasah',
                   'grade_levels',
                   'academic_term',
                   'program_schedule',
               ),
               'classes': ('collapse',),
           }),
           ('Description', {
               'fields': (
                   'description',
                   'objectives',
                   'expected_outcomes',
                   'key_performance_indicators',
               )
           }),
           ('Target Groups', {
               'fields': (
                   'target_beneficiaries',
                   'geographic_coverage',
                   'estimated_beneficiaries',
               )
           }),
           ('Enrollment', {
               'fields': (
                   'enrollment_capacity',
                   'current_enrollment',
                   'enrollment_requirements',
                   'application_deadline',
                   'enrollment_stats',
               ),
               'classes': ('collapse',),
           }),
           ('Implementation', {
               'fields': (
                   'implementation_strategy',
                   'implementing_units',
                   'partner_agencies',
               )
           }),
           ('Financial', {
               'fields': (
                   'total_budget',
                   'allocated_budget',
                   'utilized_budget',
                   'funding_source',
                   'funding_details',
               ),
               'classes': ('collapse',),
           }),
           ('Timeline', {
               'fields': (
                   'start_date',
                   'end_date',
                   'duration_months',
               )
           }),
           ('Status & Management', {
               'fields': (
                   'status',
                   'priority_level',
                   'created_by',
                   'ministry_liaison',
                   'program_manager',
                   'program_coordinator',
               )
           }),
           ('Accreditation', {
               'fields': (
                   'accreditation_status',
                   'accreditation_date',
                   'accreditation_body',
               ),
               'classes': ('collapse',),
           }),
           ('Access Control', {
               'fields': (
                   'is_public',
                   'is_featured',
                   'requires_approval',
               )
           }),
           ('Documentation', {
               'fields': (
                   'program_document',
                   'implementation_guidelines',
                   'monitoring_framework',
               ),
               'classes': ('collapse',),
           }),
           ('Integration', {
               'fields': (
                   'notion_database_id',
                   'external_system_id',
               ),
               'classes': ('collapse',),
           }),
           ('Audit', {
               'fields': (
                   'created_at',
                   'updated_at',
                   'requirements_summary',
               ),
               'classes': ('collapse',),
           }),
       )

       def program_category_badge(self, obj):
           colors = {
               'scholarship': 'success',
               'teacher_training': 'primary',
               'curriculum': 'info',
               'extracurricular': 'warning',
               'academic': 'secondary',
               'accreditation': 'dark',
           }
           color = colors.get(obj.program_category, 'secondary')
           return format_html(
               '<span class="badge bg-{}">{}</span>',
               color,
               obj.get_program_category_display()
           )
       program_category_badge.short_description = 'Category'

       def status_badge(self, obj):
           colors = {
               'active': 'success',
               'pending_approval': 'warning',
               'completed': 'secondary',
               'suspended': 'danger',
               'draft': 'light',
           }
           color = colors.get(obj.status, 'secondary')
           return format_html(
               '<span class="badge bg-{}">{}</span>',
               color,
               obj.get_status_display()
           )
       status_badge.short_description = 'Status'

       def enrollment_info(self, obj):
           if obj.enrollment_capacity:
               percentage = (obj.current_enrollment / obj.enrollment_capacity) * 100
               color = 'danger' if percentage >= 90 else 'warning' if percentage >= 70 else 'success'
               return format_html(
                   '<span class="badge bg-{}">{}/{}</span>',
                   color,
                   obj.current_enrollment,
                   obj.enrollment_capacity
               )
           return format_html('{} (unlimited)', obj.current_enrollment)
       enrollment_info.short_description = 'Enrollment'

       def enrollment_stats(self, obj):
           if obj.id:
               stats = obj.enrollments.aggregate(
                   total=Count('id'),
                   pending=Count('id', filter=models.Q(status='pending')),
                   approved=Count('id', filter=models.Q(status='approved')),
                   enrolled=Count('id', filter=models.Q(status='enrolled')),
                   completed=Count('id', filter=models.Q(status='completed')),
               )
               return format_html(
                   '<strong>Total:</strong> {} | '
                   '<strong>Pending:</strong> {} | '
                   '<strong>Approved:</strong> {} | '
                   '<strong>Enrolled:</strong> {} | '
                   '<strong>Completed:</strong> {}',
                   stats['total'],
                   stats['pending'],
                   stats['approved'],
                   stats['enrolled'],
                   stats['completed'],
               )
           return 'No enrollment data yet'
       enrollment_stats.short_description = 'Enrollment Statistics'

       def requirements_summary(self, obj):
           if obj.id:
               req_count = obj.requirements.count()
               mandatory = obj.requirements.filter(is_mandatory=True).count()
               return format_html(
                   '<strong>Total Requirements:</strong> {} '
                   '(<strong>Mandatory:</strong> {}, <strong>Optional:</strong> {})',
                   req_count,
                   mandatory,
                   req_count - mandatory
               )
           return 'No requirements defined'
       requirements_summary.short_description = 'Requirements'

       actions = [
           'mark_as_active',
           'mark_as_suspended',
           'mark_as_completed',
           'feature_programs',
           'unfeature_programs',
       ]

       def mark_as_active(self, request, queryset):
           updated = queryset.update(status='active')
           self.message_user(request, f'{updated} program(s) marked as active')
       mark_as_active.short_description = 'Mark selected programs as active'

       def mark_as_suspended(self, request, queryset):
           updated = queryset.update(status='suspended')
           self.message_user(request, f'{updated} program(s) marked as suspended')
       mark_as_suspended.short_description = 'Mark selected programs as suspended'

       def mark_as_completed(self, request, queryset):
           updated = queryset.update(status='completed')
           self.message_user(request, f'{updated} program(s) marked as completed')
       mark_as_completed.short_description = 'Mark selected programs as completed'

       def feature_programs(self, request, queryset):
           updated = queryset.update(is_featured=True)
           self.message_user(request, f'{updated} program(s) featured')
       feature_programs.short_description = 'Feature selected programs'

       def unfeature_programs(self, request, queryset):
           updated = queryset.update(is_featured=False)
           self.message_user(request, f'{updated} program(s) unfeatured')
       unfeature_programs.short_description = 'Unfeature selected programs'
   ```
2. Configure ProgramEnrollmentAdmin:
   ```python
   # Add to admin.py:
   from django.db import models

   class EnrollmentRequirementStatusInline(admin.TabularInline):
       model = EnrollmentRequirementStatus
       extra = 0
       fields = [
           'requirement',
           'is_met',
           'verification_date',
           'verified_by',
           'notes',
       ]
       readonly_fields = ['verification_date']

   @admin.register(ProgramEnrollment)
   class ProgramEnrollmentAdmin(admin.ModelAdmin):
       form = ProgramEnrollmentAdminForm
       list_display = [
           'participant_name',
           'program',
           'participant_type',
           'status_badge',
           'application_date',
           'progress_percentage',
           'attendance_rate',
           'requirements_met',
       ]
       list_filter = [
           'status',
           'participant_type',
           'application_date',
           'approval_date',
           'program__program_category',
           'program__grade_levels',
       ]
       search_fields = [
           'participant__first_name',
           'participant__last_name',
           'participant__email',
           'program__title',
           'program__code',
       ]
       date_hierarchy = 'application_date'
       readonly_fields = [
           'application_date',
           'created_at',
           'updated_at',
           'requirements_progress_display',
       ]
       inlines = [EnrollmentRequirementStatusInline]

       fieldsets = (
           ('Program & Participant', {
               'fields': (
                   'program',
                   'participant',
                   'participant_type',
               )
           }),
           ('Status', {
               'fields': (
                   'status',
                   'application_date',
                   'approval_date',
                   'enrollment_date',
                   'completion_date',
               )
           }),
           ('Application', {
               'fields': (
                   'application_notes',
                   'submitted_documents',
               )
           }),
           ('Progress Tracking', {
               'fields': (
                   'progress_percentage',
                   'attendance_rate',
                   'performance_rating',
                   'requirements_progress_display',
               )
           }),
           ('Administrative', {
               'fields': (
                   'approved_by',
                   'rejection_reason',
                   'notes',
               )
           }),
           ('Audit', {
               'fields': (
                   'created_at',
                   'updated_at',
               ),
               'classes': ('collapse',),
           }),
       )

       def participant_name(self, obj):
           return obj.participant.get_full_name()
       participant_name.short_description = 'Participant'
       participant_name.admin_order_field = 'participant__last_name'

       def status_badge(self, obj):
           colors = {
               'pending': 'warning',
               'approved': 'info',
               'enrolled': 'primary',
               'completed': 'success',
               'dropped': 'secondary',
               'rejected': 'danger',
               'waitlisted': 'light',
           }
           color = colors.get(obj.status, 'secondary')
           return format_html(
               '<span class="badge bg-{}">{}</span>',
               color,
               obj.get_status_display()
           )
       status_badge.short_description = 'Status'

       def requirements_met(self, obj):
           if obj.id:
               total = obj.requirement_statuses.count()
               if total == 0:
                   return 'N/A'
               met = obj.requirement_statuses.filter(is_met=True).count()
               percentage = int((met / total) * 100)
               color = 'success' if percentage == 100 else 'warning' if percentage >= 50 else 'danger'
               return format_html(
                   '<span class="badge bg-{}">{}/{} ({}%)</span>',
                   color,
                   met,
                   total,
                   percentage
               )
           return 'Not initialized'
       requirements_met.short_description = 'Requirements'

       def requirements_progress_display(self, obj):
           if obj.id:
               return format_html(
                   '<strong>Progress:</strong> {}%<br>'
                   '<strong>Prerequisites Met:</strong> {}<br>'
                   '<strong>Eligibility Met:</strong> {}<br>'
                   '<strong>Completion Met:</strong> {}',
                   obj.get_requirements_progress(),
                   '✓' if obj.are_prerequisites_met() else '✗',
                   '✓' if obj.are_eligibility_requirements_met() else '✗',
                   '✓' if obj.are_completion_requirements_met() else '✗',
               )
           return 'Requirements not initialized'
       requirements_progress_display.short_description = 'Requirements Progress'

       actions = [
           'approve_applications',
           'enroll_participants',
           'mark_completed',
           'initialize_requirements',
       ]

       def approve_applications(self, request, queryset):
           count = 0
           for enrollment in queryset.filter(status='pending'):
               try:
                   enrollment.approve(approved_by=request.user)
                   count += 1
               except Exception as e:
                   self.message_user(request, f'Error approving {enrollment}: {str(e)}', level='error')
           self.message_user(request, f'{count} application(s) approved')
       approve_applications.short_description = 'Approve selected applications'

       def enroll_participants(self, request, queryset):
           count = 0
           for enrollment in queryset.filter(status='approved'):
               try:
                   enrollment.enroll()
                   count += 1
               except Exception as e:
                   self.message_user(request, f'Error enrolling {enrollment}: {str(e)}', level='error')
           self.message_user(request, f'{count} participant(s) enrolled')
       enroll_participants.short_description = 'Enroll approved participants'

       def mark_completed(self, request, queryset):
           count = 0
           for enrollment in queryset.filter(status='enrolled'):
               enrollment.complete()
               count += 1
           self.message_user(request, f'{count} enrollment(s) marked as completed')
       mark_completed.short_description = 'Mark as completed'

       def initialize_requirements(self, request, queryset):
           count = 0
           for enrollment in queryset:
               enrollment.initialize_requirements()
               count += 1
           self.message_user(request, f'Requirements initialized for {count} enrollment(s)')
       initialize_requirements.short_description = 'Initialize requirements tracking'
   ```
3. Configure ProgramRequirementAdmin:
   ```python
   # Add to admin.py:
   @admin.register(ProgramRequirement)
   class ProgramRequirementAdmin(admin.ModelAdmin):
       list_display = [
           'title',
           'program',
           'requirement_type_badge',
           'is_mandatory',
           'order',
       ]
       list_filter = [
           'requirement_type',
           'is_mandatory',
           'program__program_category',
       ]
       search_fields = [
           'title',
           'description',
           'program__title',
       ]
       ordering = ['program', 'order']

       fieldsets = (
           (None, {
               'fields': (
                   'program',
                   'requirement_type',
                   'title',
                   'description',
               )
           }),
           ('Settings', {
               'fields': (
                   'is_mandatory',
                   'verification_method',
                   'order',
               )
           }),
       )

       def requirement_type_badge(self, obj):
           colors = {
               'prerequisite': 'warning',
               'eligibility': 'info',
               'completion': 'success',
               'documentation': 'secondary',
           }
           color = colors.get(obj.requirement_type, 'secondary')
           return format_html(
               '<span class="badge bg-{}">{}</span>',
               color,
               obj.get_requirement_type_display()
           )
       requirement_type_badge.short_description = 'Type'
   ```
4. Configure EnrollmentRequirementStatusAdmin:
   ```python
   # Add to admin.py:
   @admin.register(EnrollmentRequirementStatus)
   class EnrollmentRequirementStatusAdmin(admin.ModelAdmin):
       form = RequirementVerificationForm
       list_display = [
           'enrollment_info',
           'requirement',
           'is_met_badge',
           'verification_date',
           'verified_by',
       ]
       list_filter = [
           'is_met',
           'requirement__requirement_type',
           'verification_date',
       ]
       search_fields = [
           'enrollment__participant__first_name',
           'enrollment__participant__last_name',
           'requirement__title',
       ]
       readonly_fields = ['verification_date', 'created_at', 'updated_at']

       fieldsets = (
           ('Enrollment & Requirement', {
               'fields': (
                   'enrollment',
                   'requirement',
               )
           }),
           ('Verification', {
               'fields': (
                   'is_met',
                   'verification_date',
                   'verified_by',
                   'supporting_document',
                   'notes',
               )
           }),
           ('Audit', {
               'fields': (
                   'created_at',
                   'updated_at',
               ),
               'classes': ('collapse',),
           }),
       )

       def enrollment_info(self, obj):
           return f"{obj.enrollment.participant.get_full_name()} - {obj.enrollment.program.title}"
       enrollment_info.short_description = 'Enrollment'

       def is_met_badge(self, obj):
           if obj.is_met:
               return format_html('<span class="badge bg-success">✓ Met</span>')
           return format_html('<span class="badge bg-danger">✗ Not Met</span>')
       is_met_badge.short_description = 'Status'

       def save_model(self, request, obj, form, change):
           if obj.is_met and not obj.verified_by:
               obj.verified_by = request.user
               from django.utils import timezone
               obj.verification_date = timezone.now()
           super().save_model(request, obj, form, change)

       actions = ['mark_requirements_met', 'mark_requirements_unmet']

       def mark_requirements_met(self, request, queryset):
           count = 0
           for status in queryset:
               status.mark_as_met(verified_by=request.user)
               count += 1
           self.message_user(request, f'{count} requirement(s) marked as met')
       mark_requirements_met.short_description = 'Mark as met'

       def mark_requirements_unmet(self, request, queryset):
           count = 0
           for status in queryset:
               status.mark_as_unmet()
               count += 1
           self.message_user(request, f'{count} requirement(s) marked as not met')
       mark_requirements_unmet.short_description = 'Mark as not met'
   ```
5. Test admin interface:
   ```bash
   cd /Users/saidamenmambayao/apps/madaris-ms/src
   python manage.py check
   ```
6. Verify admin registrations:
   ```bash
   python manage.py shell -c "
   from django.contrib import admin
   from apps.services.models import (
       MinistryProgram,
       ProgramEnrollment,
       ProgramRequirement,
       EnrollmentRequirementStatus
   )

   models = [MinistryProgram, ProgramEnrollment, ProgramRequirement, EnrollmentRequirementStatus]
   for model in models:
       if admin.site.is_registered(model):
           admin_class = admin.site._registry[model]
           print(f'✓ {model.__name__} registered as {admin_class.__class__.__name__}')
       else:
           print(f'✗ {model.__name__} NOT registered')
   "
   ```
7. Create admin test data:
   ```bash
   python manage.py shell -c "
   from apps.services.models import MinistryProgram, ProgramEnrollment, ProgramRequirement
   from apps.users.models import User
   from datetime import date, timedelta

   admin = User.objects.filter(is_superuser=True).first()

   # Create program
   program = MinistryProgram.objects.create(
       code='ADMIN_TEST_001',
       title='Admin Interface Test Program',
       slug='admin-test-program',
       ministry='mbasiced',
       program_source='education',
       program_category='scholarship',
       ppa_type='program',
       description='Testing admin interface',
       objectives='Test',
       expected_outcomes='Test',
       key_performance_indicators='Test',
       target_beneficiaries='Students',
       geographic_coverage='BARMM',
       implementation_strategy='Test',
       implementing_units='Test',
       start_date=date.today(),
       end_date=date.today() + timedelta(days=365),
       funding_source='regional',
       created_by=admin,
       status='active',
       enrollment_capacity=20,
       is_featured=True,
   )

   # Add requirements
   for i in range(3):
       ProgramRequirement.objects.create(
           program=program,
           requirement_type='eligibility',
           title=f'Requirement {i+1}',
           description=f'Test requirement {i+1}',
           is_mandatory=True,
           order=i+1
       )

   # Create enrollments
   for i in range(5):
       student = User.objects.create_user(
           username=f'admin_test_student_{i}',
           email=f'student{i}@admin.test',
           first_name=f'Student{i}',
           last_name='AdminTest',
           role='student'
       )
       enrollment = ProgramEnrollment.objects.create(
           program=program,
           participant=student,
           participant_type='student',
           status=['pending', 'approved', 'enrolled'][i % 3],
           progress_percentage=i * 20,
       )
       enrollment.initialize_requirements()

   print(f'✓ Created test program: {program.title}')
   print(f'  Requirements: {program.requirements.count()}')
   print(f'  Enrollments: {program.enrollments.count()}')
   print('\\nVisit Django admin to verify:')
   print('  /admin/services/ministryprogram/')
   print('  /admin/services/programenrollment/')
   print('  /admin/services/programrequirement/')
   "
   ```
8. Test admin actions:
   ```bash
   python manage.py shell -c "
   from apps.services.models import ProgramEnrollment
   from apps.users.models import User

   admin = User.objects.filter(is_superuser=True).first()

   # Test approve action
   pending = ProgramEnrollment.objects.filter(status='pending').first()
   if pending:
       pending.approve(approved_by=admin)
       print(f'✓ Approved enrollment: {pending}')
       print(f'  Status: {pending.get_status_display()}')

   # Test enroll action
   approved = ProgramEnrollment.objects.filter(status='approved').first()
   if approved:
       approved.enroll()
       print(f'✓ Enrolled participant: {approved}')
       print(f'  Status: {approved.get_status_display()}')
   "
   ```
9. Verify fieldsets and readonly fields:
   ```bash
   python manage.py shell -c "
   from django.contrib import admin
   from apps.services.models import MinistryProgram

   admin_class = admin.site._registry[MinistryProgram]
   print('MinistryProgramAdmin Configuration:')
   print(f'  List display fields: {len(admin_class.list_display)}')
   print(f'  List filters: {len(admin_class.list_filter)}')
   print(f'  Search fields: {len(admin_class.search_fields)}')
   print(f'  Fieldsets: {len(admin_class.fieldsets)}')
   print(f'  Actions: {len([a for a in admin_class.actions if not a.startswith(\"_\")])}')
   print(f'  Inlines: {len(admin_class.inlines)}')
   print('\\n✓ Admin configuration verified')
   "
   ```
10. Clean up test data:
    ```bash
    python manage.py shell -c "
    from apps.services.models import MinistryProgram, ProgramEnrollment
    from apps.users.models import User

    # Clean up test program and related data
    program = MinistryProgram.objects.filter(code='ADMIN_TEST_001').first()
    if program:
        # Delete enrollments will cascade
        program.delete()
        print('✓ Test program deleted')

    # Clean up test users
    User.objects.filter(username__startswith='admin_test_student_').delete()
    print('✓ Test users deleted')
    "
    ```

## Acceptance Criteria:
- MinistryProgramAdmin updated with education fields
- ProgramEnrollmentAdmin configured
- ProgramRequirementAdmin configured
- EnrollmentRequirementStatusAdmin configured
- Custom admin actions added
- List filters configured
- Search fields optimized
- Fieldsets organized logically
- Inlines added for related models
- Admin interface tested

## Files Modified:
- `src/apps/services/admin.py (major updates)`

## Important Notes:
- All admin classes include custom actions for workflow operations
- Badge displays for better visual status indicators
- Inlines for related models (requirements, enrollment status)
- Comprehensive fieldsets for logical organization
- Search and filter optimizations for large datasets
- Custom methods for displaying computed values
- Readonly fields for audit and computed data
- Actions support bulk operations on selected items
- Admin saves automatically update metadata (verified_by, dates)
- Estimate: 70 minutes

# Test Strategy:
1. Run migrations and verify schema changes
2. Create test instances to verify new fields
3. Test admin interface with new fields
4. Verify backward compatibility with existing data
5. Login to Django admin as superuser
6. Verify models appear in admin interface
7. Test create, read, update, delete operations
8. Verify list display, filters, and search work