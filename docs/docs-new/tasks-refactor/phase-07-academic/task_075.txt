# Task ID: 075
# Title: Create Class Model
# Status: pending
# Dependencies: 074
# Priority: medium
# Description: Create Class model to represent teaching classes/sections with teacher assignments, subject associations, and schedule management.

# Details:
Create Class model to represent teaching classes/sections with teacher assignments, subject associations, and schedule management.

## Implementation Steps:
1. Create Class model:
   ```python
   # apps/academics/models.py (add to existing file)
   from apps.madrasahs.models import Madrasah
   from apps.curriculum.models import Subject
   from django.conf import settings

   class Class(models.Model):
       """Teaching class/section for a specific subject"""

       GRADE_LEVELS = [
           ('kg', 'Kindergarten'),
           ('grade1', 'Grade 1'),
           ('grade2', 'Grade 2'),
           ('grade3', 'Grade 3'),
           ('grade4', 'Grade 4'),
           ('grade5', 'Grade 5'),
           ('grade6', 'Grade 6'),
           ('grade7', 'Grade 7'),
           ('grade8', 'Grade 8'),
           ('grade9', 'Grade 9'),
           ('grade10', 'Grade 10'),
           ('grade11', 'Grade 11'),
           ('grade12', 'Grade 12'),
           ('alimiyya', 'Alimiyya/Advanced Islamic Studies'),
           ('tahfidh', 'Tahfidh (Quran Memorization)'),
       ]

       SECTION_CHOICES = [
           ('A', 'Section A'),
           ('B', 'Section B'),
           ('C', 'Section C'),
           ('D', 'Section D'),
           ('E', 'Section E'),
       ]

       # Core relationships
       madrasah = models.ForeignKey(
           Madrasah,
           on_delete=models.CASCADE,
           related_name='classes',
           help_text="Madrasah offering this class"
       )

       academic_year = models.ForeignKey(
           AcademicYear,
           on_delete=models.CASCADE,
           related_name='classes',
           help_text="Academic year for this class"
       )

       teacher = models.ForeignKey(
           settings.AUTH_USER_MODEL,
           on_delete=models.SET_NULL,
           null=True,
           blank=True,
           limit_choices_to={'role': 'asatidz'},
           related_name='teaching_classes',
           help_text="Primary teacher (Ustadz/Ustadza)"
       )

       subject = models.ForeignKey(
           Subject,
           on_delete=models.CASCADE,
           related_name='classes',
           help_text="Subject being taught"
       )

       # Class identification
       grade_level = models.CharField(
           max_length=20,
           choices=GRADE_LEVELS,
           help_text="Grade level for this class"
       )

       section = models.CharField(
           max_length=5,
           choices=SECTION_CHOICES,
           help_text="Section identifier"
       )

       class_code = models.CharField(
           max_length=50,
           unique=True,
           help_text="Unique class code (e.g., 'QURAN-G5-A-2024')"
       )

       # Schedule and logistics
       schedule = models.JSONField(
           default=dict,
           help_text="Class schedule: {'Monday': ['8:00-9:00'], 'Wednesday': ['10:00-11:00']}"
       )

       room = models.CharField(
           max_length=50,
           blank=True,
           help_text="Room number/name"
       )

       # Capacity management
       max_students = models.PositiveIntegerField(
           default=30,
           help_text="Maximum student capacity"
       )

       # Additional info
       description = models.TextField(
           blank=True,
           help_text="Class description and objectives"
       )

       notes = models.TextField(
           blank=True,
           help_text="Internal notes"
       )

       # Status
       is_active = models.BooleanField(default=True)

       # Metadata
       created_at = models.DateTimeField(auto_now_add=True)
       updated_at = models.DateTimeField(auto_now=True)

       class Meta:
           db_table = 'academics_class'
           verbose_name = 'Class'
           verbose_name_plural = 'Classes'
           ordering = ['madrasah', 'grade_level', 'section', 'subject']
           unique_together = [
               ['madrasah', 'academic_year', 'subject', 'grade_level', 'section']
           ]

       def __str__(self):
           return f"{self.subject.name} - {self.get_grade_level_display()} {self.section}"

       def save(self, *args, **kwargs):
           # Auto-generate class_code if not provided
           if not self.class_code:
               subject_code = self.subject.code[:6].upper()
               grade = self.grade_level.upper()
               year = self.academic_year.year.split('-')[0]
               self.class_code = f"{subject_code}-{grade}-{self.section}-{year}"
           super().save(*args, **kwargs)

       @property
       def enrolled_count(self):
           """Count of enrolled students"""
           return self.enrollments.filter(status='enrolled').count()

       @property
       def available_seats(self):
           """Number of available seats"""
           return max(0, self.max_students - self.enrolled_count)

       @property
       def is_full(self):
           """Check if class is at capacity"""
           return self.enrolled_count >= self.max_students

       @property
       def teacher_name(self):
           """Get teacher's full name"""
           return self.teacher.get_full_name() if self.teacher else 'Unassigned'

       def get_schedule_display(self):
           """Format schedule for display"""
           if not self.schedule:
               return "No schedule set"

           schedule_list = []
           for day, times in self.schedule.items():
               times_str = ', '.join(times)
               schedule_list.append(f"{day}: {times_str}")
           return ' | '.join(schedule_list)
   ```

2. Create ClassEnrollment model for student enrollments:
   ```python
   # apps/academics/models.py (add after Class model)

   class ClassEnrollment(models.Model):
       """Student enrollment in a specific class"""

       STATUS_CHOICES = [
           ('enrolled', 'Enrolled'),
           ('dropped', 'Dropped'),
           ('completed', 'Completed'),
           ('withdrawn', 'Withdrawn'),
       ]

       class_instance = models.ForeignKey(
           Class,
           on_delete=models.CASCADE,
           related_name='enrollments'
       )

       student = models.ForeignKey(
           settings.AUTH_USER_MODEL,
           on_delete=models.CASCADE,
           limit_choices_to={'role': 'student'},
           related_name='class_enrollments'
       )

       enrollment_date = models.DateField(
           auto_now_add=True,
           help_text="Date student enrolled in class"
       )

       status = models.CharField(
           max_length=20,
           choices=STATUS_CHOICES,
           default='enrolled'
       )

       # Performance tracking
       midterm_grade = models.DecimalField(
           max_digits=5,
           decimal_places=2,
           null=True,
           blank=True,
           help_text="Midterm grade"
       )

       final_grade = models.DecimalField(
           max_digits=5,
           decimal_places=2,
           null=True,
           blank=True,
           help_text="Final grade"
       )

       # Metadata
       notes = models.TextField(blank=True)
       created_at = models.DateTimeField(auto_now_add=True)
       updated_at = models.DateTimeField(auto_now=True)

       class Meta:
           db_table = 'academics_class_enrollment'
           verbose_name = 'Class Enrollment'
           verbose_name_plural = 'Class Enrollments'
           unique_together = [['class_instance', 'student']]
           ordering = ['class_instance', 'student__last_name']

       def __str__(self):
           return f"{self.student.get_full_name()} in {self.class_instance}"

       @property
       def overall_grade(self):
           """Calculate overall grade (average of midterm and final)"""
           if self.midterm_grade and self.final_grade:
               return (self.midterm_grade + self.final_grade) / 2
           return self.final_grade or self.midterm_grade
   ```

3. Create migration:
   ```bash
   python manage.py makemigrations academics
   ```

4. Apply migration:
   ```bash
   python manage.py migrate academics
   ```

5. Test model in shell:
   ```python
   from apps.academics.models import Class, ClassEnrollment, AcademicYear
   from apps.madrasahs.models import Madrasah
   from apps.curriculum.models import Subject
   from apps.users.models import User

   # Get required objects
   madrasah = Madrasah.objects.first()
   academic_year = AcademicYear.objects.get(status='active')
   teacher = User.objects.filter(role='asatidz').first()
   subject = Subject.objects.first()

   # Create class
   class_obj = Class.objects.create(
       madrasah=madrasah,
       academic_year=academic_year,
       teacher=teacher,
       subject=subject,
       grade_level='grade5',
       section='A',
       schedule={
           'Monday': ['8:00-9:00'],
           'Wednesday': ['8:00-9:00'],
           'Friday': ['8:00-9:00']
       },
       room='Room 101',
       max_students=25
   )

   # Enroll student
   student = User.objects.filter(role='student').first()
   enrollment = ClassEnrollment.objects.create(
       class_instance=class_obj,
       student=student,
       status='enrolled'
   )

   # Test properties
   print(class_obj.enrolled_count)
   print(class_obj.available_seats)
   print(class_obj.get_schedule_display())
   ```

## Acceptance Criteria:
- Class model created
- Links to Madrasah, Teacher, Subject
- Grade level and section fields
- Schedule stored in JSONField
- Student capacity tracking
- Room assignment support
- Migration created successfully
- Model accessible in admin

## Files Modified:
- `src/apps/academics/models.py`
- `src/apps/academics/migrations/0002_class.py`

## Important Notes:
- Class represents a teaching section, not a grade level
- Supports flexible scheduling via JSONField
- ClassEnrollment tracks student participation
- Auto-generates class codes
- Unique constraint prevents duplicate class sections
- Estimate: 60 minutes

# Test Strategy:
1. Run migrations and verify schema changes
2. Create test instances to verify new fields
3. Test admin interface with new fields
4. Verify backward compatibility with existing data